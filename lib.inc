%define exit_call 60 ; Коды системных вызовов
%define write_call 1
%define read_call 0

%define stdin 0  ; Стандартные дескрипторы
%define stdout 1
%define stderr 2

global exit, string_length, print_string, print_char, print_newline
global print_uint, print_int, string_equals, read_char, read_word
global parse_uint, parse_int, string_copy

section .text
; Принимает код возврата и завершает текущий процесс
; @param rdi Код возврата
exit: 
    mov rax, exit_call
    ;xor rdi, rdi
    syscall

; Принимает указатель на нуль-терминированную строку, возвращает её длину
; @param rdi Указатель на адрес начала буфера 
; @return rax Кол-во символов в строке без символа конца строки
string_length:
    xor rax, rax              ; Обнуление счетчика
    
    .loop:
    	cmp byte[rdi+rax], `\0` ; Сравнение следующего символа с символом конца строки
    	je .end                 ; Если равно, то перейти к концу
    	inc rax                 ; Иначе увеличить счетки на 1
    	jmp .loop             
    	
    .end:
    	ret

; Принимает указатель на нуль-терминированную строку, выводит её в stdout
; @param rdi Указатель на адрес начала буфера
print_string:
    push rdi           ; Сохранение caller-регистров
    call string_length ; Подсчет длины строки
    pop rdi            ; Восстановление caller-регистров
   
    mov rsi, rdi       ; Вывод строки в stdout
    mov rdx, rax
    mov rax, write_call
    mov rdi, stdout
    syscall
    
    ret

; Переводит строку
print_newline:
    mov rdi, `\n`; Вывод символа \n в stdout
   
; Принимает код символа и выводит его в stdout
; @param rdi Код символа в кодировке ASCII  
print_char:
    push rdi     ; Помещение символа в стек, чтобы избежать затирания
    
    mov rsi, rsp ; Вывод символа в stdout
    mov rdx, 1
    mov rax, write_call
    mov rdi, stdout
    syscall
    
    pop rdi      ; Очищение стека от локальных данных
    ret
    
; Выводит знаковое 8-байтовое число в десятичном формате
; @param rdi Целое знаковое число
print_int:
    cmp rdi, 0              ; Если число больше 0, то
    jns .pos_num            ; перейти к метке вывода беззнакового числа
         
    .neg_num:               ; Вывод отрицательного числа в stdout
        push rdi            ; Сохранение caller-регистра перед вызовом функции       
        mov rdi, `-`        ; Вывод символа - в stdout
        call print_char     
        pop rdi             ; Восстановление caller-регистра
        
        neg rdi             ; Преобразование числа в беззнаковое

    .pos_num:               ; Вызов функции вывода беззнакового числа в stdout

 ; Выводит беззнаковое 8-байтовое число в десятичном формате 
; @param rdi Целое беззнаковое число
print_uint:
    push r13              ; Сохранение callee-регистров перед изменением
    push r12
    
    mov r12, rsp          ; Помещение символа конца строки в стеке
    push `\0`
    
    mov r13, 10           ; Константа для деления
    mov rax, rdi    
    .loop:
        xor rdx, rdx      ; Деление числа на 10 и
        div r13           ; преобразование остатка в ASCII код
        add rdx, 0x30
        
        dec rsp           ; Сохранение символа в стеке
        mov byte[rsp], dl
        
        test rax, rax     ; Если целое от деления не равно 0,
        jnz .loop         ; то перейти на следующую итерацию
    
    mov rdi, rsp          ; Вызов функции вывода строки в stdout
    call print_string     ; Сохранение caller-регистров не производится,
                          ; так как дальше в функции их начальные значения не используются   
    mov rsp, r12          ; Очищение стека
    pop r12               ; Восстановление callee-регистров
    pop r13
    
    ret

; Принимает два указателя на нуль-терминированные строки, возвращает 1 если они равны, 0 иначе
; @param rdi Указатель на адрес начала буфера первой строки
; @param rsi Указатель на адрес начала буфера второй строки
; @return rax 1, если строки равны, иначе 0
string_equals:
    push r12                    ; Сохранение callee-регистров перед изменением
    push rdi                    ; Сохранение caller-регистров перед вызовом функций
    push rsi
    call string_length          ; Получение длины первой строки
    mov r12, rax   
    mov rdi, rsi                ; Получение длины второй строки
    call string_length
    pop rsi                     ; Восстановление caller-регистров
    pop rdi
    
    cmp r12, rax                ; Если длина строк не совпадает, то
    jnz .is_diff                ; вернуть 0
    
    .loop:
        cmp r12, 0              ; Если индекс символа равен 0, то
        jl .is_equal            ; вернуть 1
        
        mov cl, byte[rdi + r12] 
        cmp cl, byte[rsi + r12] ; Если символы не совпадают, то
        jnz .is_diff            ; вернуть 0
        
        dec r12                 ; Уменьшение индекса символа
        jmp .loop
        
    .is_equal:                  ; Вернуть 1
        pop r12                 ; Восстановление callee-регистров
        mov rax, 1
        ret
        
    .is_diff:                   ; Вернуть 0
        pop r12                 ; Восстановление callee-регистров
        xor rax, rax
        ret
    
; Читает один символ из stdin и возвращает его. Возвращает 0 если достигнут конец потока
; @return rax Код символа в кодировке ASCII или 0
read_char:
    push 0x0           ; Помещение возвращаемого значения в стек
     
    mov rax, read_call ; Чтение символа из stdin в стек
    mov rdi, stdin
    mov rdx, 1
    mov rsi, rsp
    syscall
    
    pop rax       ; Очищение стека и сохранение возвращаемого значения
    
    ret 

; Читает в буфер слово из stdin, пропуская пробельные символы в начале
; @param rdi Указатель на адрес начала буфера 
; @param rsi Размер буфера
; @return rax Указатель на адрес начала буфера или 0
; @return rdx Длина полученной строки без символа конца-строки или 0
read_word:   
    xor rdx, rdx                  ; Обнуления длины строки
    .loop:
        cmp rsi, rdx              ; Если длина строки совпала с размером буфера, то
        je .is_buffer_end         ; вернуть ошибку переполнения буфера
        
        push rdi                  ; Сохранение caller-регистров перед вызовом функции
        push rsi
        push rdx
        call read_char            ; Чтение символа из stdin
        pop rdx                   ; Восстановление caller-регистров
        pop rsi
        pop rdi
        
        cmp al, `\0`              ; Если символ равен символу конца строки, то
        je .is_end                ; выйти из цикла
        cmp al, 0x04              ; Если символ равен символу конца передачи данных, то
        je .is_end                ; выйти из цикла
        cmp al, ` `               ; Если символ равен space, то
        je .is_space              ; перейти к выбору действия
        cmp al, `\n`              ; Если символ равен \n, то
        je .is_space              ; перейти к выбору действия
        cmp al, `\t`              ; Если символ равен \t, то
        je .is_space              ; перейти к выбору действия
        
        mov byte[rdi + rdx], al   ; Сохранение прочитанного символа в буфер
        inc rdx                   ; Увеличение длины полученной строки
        
        jmp .loop
    
    .is_space:                    ; Пропуск пробельных символов в начале
        cmp rdx, 0                ; Если длина строки равна 0, то
        je .loop                  ; вернуться в цикл
        jmp .is_end               ; иначе выйти из цикла
   
    .is_end:                      ; Конец чтения
        mov byte[rdi + rdx], `\0` ; Помещение символа конца строки в буфер
        mov rax, rdi              
        ret
        
    .is_buffer_end:               ; Ошибка переполнения буфера
        xor rdx, rdx              ; Обнуление возвращаемых значений
        xor rax, rax
        ret

; Принимает указатель на строку, пытается
; прочитать из её начала беззнаковое число.
; Возвращает в rax: число, rdx : его длину в символах
; rdx = 0 если число прочитать не удалось
; @param rdi Указатель на адрес начала буфера строки
; @return rax Целое беззнаковое число или 0
; @return rdx Длина числа в символах или 0
parse_uint:
    push r12                      ; Сохранение callee-регистров перед изменением
    push r13
    
    mov r13, 10                   ; Константа для умножения
    
    xor rdx, rdx                  ; Обнуление необходимых регистров
    xor r12, r12
    xor rax, rax
    .loop:
        mov r12b, byte[rdi + rdx] ; Получение символа из строки
        cmp r12b, 0x30            ; Если код символа меньше 0x30, то
        jl .is_end                ; выйти из цикла
        cmp r12b, 0x39            ; Если код символа больше 0x39, то
        jg .is_end                ; выйти из цикла
        
        sub r12b, 0x30            ; Преобразование символа в число
        push rdx                  ; Сохранение длины числа
        mul r13                   ; Увеличение разрядов текущего числа
        add rax, r12              ; Добавление текущего числа
        pop rdx
        
        inc rdx                   ; Увеличение длины числа
        jmp .loop
        
    .is_end:                      ; Конец преобразования
        pop r13                   ; Восстановление callee-регистров
        pop r12
        
    ret
    
; Принимает указатель на строку, пытается
; прочитать из её начала знаковое число.
; Если есть знак, пробелы между ним и числом не разрешены.
; Возвращает в rax: число, rdx : его длину в символах (включая знак, если он был) 
; rdx = 0 если число прочитать не удалось
; @param rdi Указатель на адрес начала буфера строки
; @return rax Целое знаковое число или 0
; @return rdx Длина числа в символах или 0
parse_int:
    push r12              ; Сохранение callee-регистров перед изменением
    
    xor r12, r12          ; Обнуление необходимых регистров
    xor rax, rax
    .check_num:
        mov al, byte[rdi] ; Проверка первого символа в строке
        cmp al, `-`       ; Если символ не равен -, то
        jne .parse_num    ; перейти к парсингу числа 
        
        inc rdi           ; Сдвиг к следующему символу
        mov r12, 1        ; Флаг отрицательного числа
    
    .parse_num:
        call parse_uint   ; Парсинг целого беззнакового числа, 
                          ; caller-регистры не сохраняются, так как
                          ; их начальные значения не используются дальше в функции
        cmp rdx, 0        ; Если длина числа равна 0, то
        je .is_end        ; перейти к концу
        cmp r12, 0        ; Если флаг отрицательного числа не установлен, то
        je .is_end        ; перейти к концу
        
    	inc rdx           ; Увеличение длины числа
    	neg rax           ; Преобразование в отрицательное число 
    
    .is_end:
        pop r12           ; Восстановление callee-регистров
    
    ret

; Принимает указатель на строку, указатель на буфер и длину буфера
; Копирует строку в буфер
; Возвращает длину строки если она умещается в буфер, иначе 0
; @param rdi Указатель на адрес начала строки
; @param rsi Указатель на адрес начала буфера
; @param rdx Размер буфера
; @return rax Длина итоговой строки или 0
string_copy:
    push r12                      ; Сохранение callee-регистров перед изменением
    push rdi                      ; Сохранение caller-регистров перед вызовом функции
    push rsi
    push rdx
    call string_length            ; Подсчет длины исходной строки
    pop rdx                       ; Восстановление caller-регистров
    pop rsi
    pop rdi
    
    cmp rax, rdx                  ; Если длина исходной строки больше или равно буферу,
    jge .no_copy                  ; то прекратить копирование
    
    inc rax                       ; Увеличение длины строки для учета символа конца строки
    xor rdx, rdx
    .loop:
        cmp rdx, rax              ; Если длина копируемой строки больше длины исходной,
        jg .copy                  ; то закончить копирование
        
        mov r12b, byte[rdi + rdx] ; Копирование символа
        mov byte[rsi + rdx], r12b
        inc rdx                   ; Увеличение длины копируемой строки
        jmp .loop
    
    .copy:                        ; Копирование прошло успешно
        pop r12                   ; Восстановление callee-регистров
        dec rax                   ; Уменьшения длины строки для исключения символа конца
                                  ; строки
        ret
    
    .no_copy:                     ; Копирование не удалось
        pop r12                   ; Восстановление callee-регистров
        xor rax, rax              ; Обнуление длины строки
        ret
